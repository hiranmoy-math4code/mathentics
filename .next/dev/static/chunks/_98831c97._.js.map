{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/components/ErrorBoundary.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport React, { Component, ReactNode } from \"react\";\r\n\r\ninterface Props {\r\n    children: ReactNode;\r\n    fallback?: ReactNode;\r\n    onError?: (error: Error, errorInfo: React.ErrorInfo) => void;\r\n}\r\n\r\ninterface State {\r\n    hasError: boolean;\r\n    error: Error | null;\r\n}\r\n\r\nexport class ErrorBoundary extends Component<Props, State> {\r\n    constructor(props: Props) {\r\n        super(props);\r\n        this.state = { hasError: false, error: null };\r\n    }\r\n\r\n    static getDerivedStateFromError(error: Error): State {\r\n        return { hasError: true, error };\r\n    }\r\n\r\n    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\r\n        console.error(\"ErrorBoundary caught an error:\", error, errorInfo);\r\n        this.props.onError?.(error, errorInfo);\r\n    }\r\n\r\n    render() {\r\n        if (this.state.hasError) {\r\n            if (this.props.fallback) {\r\n                return this.props.fallback;\r\n            }\r\n\r\n            return (\r\n                <div className=\"min-h-screen flex items-center justify-center bg-linear-to-br from-red-50 to-red-100 dark:from-red-950 dark:to-slate-950 p-4\">\r\n                    <div className=\"max-w-md w-full bg-white dark:bg-slate-900 rounded-2xl shadow-2xl p-8 border border-red-200 dark:border-red-900\">\r\n                        <div className=\"flex items-center gap-3 mb-4\">\r\n                            <div className=\"w-12 h-12 rounded-full bg-red-100 dark:bg-red-900/30 flex items-center justify-center\">\r\n                                <svg\r\n                                    className=\"w-6 h-6 text-red-600 dark:text-red-400\"\r\n                                    fill=\"none\"\r\n                                    viewBox=\"0 0 24 24\"\r\n                                    stroke=\"currentColor\"\r\n                                >\r\n                                    <path\r\n                                        strokeLinecap=\"round\"\r\n                                        strokeLinejoin=\"round\"\r\n                                        strokeWidth={2}\r\n                                        d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\"\r\n                                    />\r\n                                </svg>\r\n                            </div>\r\n                            <h2 className=\"text-2xl font-bold text-slate-900 dark:text-white\">\r\n                                Something went wrong\r\n                            </h2>\r\n                        </div>\r\n\r\n                        <p className=\"text-slate-600 dark:text-slate-400 mb-6\">\r\n                            We encountered an unexpected error. Please try refreshing the page or contact\r\n                            support if the problem persists.\r\n                        </p>\r\n\r\n                        {this.state.error && (\r\n                            <details className=\"mb-6 p-4 bg-slate-50 dark:bg-slate-800 rounded-lg border border-slate-200 dark:border-slate-700\">\r\n                                <summary className=\"cursor-pointer text-sm font-medium text-slate-700 dark:text-slate-300\">\r\n                                    Error Details\r\n                                </summary>\r\n                                <pre className=\"mt-2 text-xs text-red-600 dark:text-red-400 overflow-auto\">\r\n                                    {this.state.error.toString()}\r\n                                </pre>\r\n                            </details>\r\n                        )}\r\n\r\n                        <button\r\n                            onClick={() => window.location.reload()}\r\n                            className=\"w-full py-3 px-4 bg-red-600 hover:bg-red-700 text-white font-medium rounded-xl transition-colors shadow-lg shadow-red-900/20\"\r\n                        >\r\n                            Reload Page\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            );\r\n        }\r\n\r\n        return this.props.children;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;AAEA;AAFA;;;AAeO,MAAM,sBAAsB,0KAAS;IACxC,YAAY,KAAY,CAAE;QACtB,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG;YAAE,UAAU;YAAO,OAAO;QAAK;IAChD;IAEA,OAAO,yBAAyB,KAAY,EAAS;QACjD,OAAO;YAAE,UAAU;YAAM;QAAM;IACnC;IAEA,kBAAkB,KAAY,EAAE,SAA0B,EAAE;QACxD,QAAQ,KAAK,CAAC,kCAAkC,OAAO;QACvD,IAAI,CAAC,KAAK,CAAC,OAAO,GAAG,OAAO;IAChC;IAEA,SAAS;QACL,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;YACrB,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;gBACrB,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ;YAC9B;YAEA,qBACI,6LAAC;gBAAI,WAAU;0BACX,cAAA,6LAAC;oBAAI,WAAU;;sCACX,6LAAC;4BAAI,WAAU;;8CACX,6LAAC;oCAAI,WAAU;8CACX,cAAA,6LAAC;wCACG,WAAU;wCACV,MAAK;wCACL,SAAQ;wCACR,QAAO;kDAEP,cAAA,6LAAC;4CACG,eAAc;4CACd,gBAAe;4CACf,aAAa;4CACb,GAAE;;;;;;;;;;;;;;;;8CAId,6LAAC;oCAAG,WAAU;8CAAoD;;;;;;;;;;;;sCAKtE,6LAAC;4BAAE,WAAU;sCAA0C;;;;;;wBAKtD,IAAI,CAAC,KAAK,CAAC,KAAK,kBACb,6LAAC;4BAAQ,WAAU;;8CACf,6LAAC;oCAAQ,WAAU;8CAAwE;;;;;;8CAG3F,6LAAC;oCAAI,WAAU;8CACV,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ;;;;;;;;;;;;sCAKtC,6LAAC;4BACG,SAAS,IAAM,OAAO,QAAQ,CAAC,MAAM;4BACrC,WAAU;sCACb;;;;;;;;;;;;;;;;;QAMjB;QAEA,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ;IAC9B;AACJ"}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/lib/provider/Provider.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport React from \"react\";\r\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\r\nimport { ReactQueryDevtools } from \"@tanstack/react-query-devtools\";\r\nimport { ErrorBoundary } from \"@/components/ErrorBoundary\";\r\nimport toast from \"react-hot-toast\";\r\n\r\n// Global error handler for queries\r\nfunction handleQueryError(error: unknown) {\r\n  const message = error instanceof Error ? error.message : \"An unexpected error occurred\";\r\n  console.error(\"Query Error:\", error);\r\n  toast.error(message);\r\n}\r\n\r\n// Global error handler for mutations\r\nfunction handleMutationError(error: any) {\r\n  let message = \"Operation failed\";\r\n  if (error instanceof Error) {\r\n    message = error.message;\r\n  } else if (typeof error === \"object\" && error !== null) {\r\n    message = error.message || error.error_description || error.details || JSON.stringify(error);\r\n  }\r\n\r\n  console.error(\"Mutation Error Detailed:\", {\r\n    error,\r\n    message,\r\n    type: typeof error\r\n  });\r\n  toast.error(message);\r\n}\r\n\r\nexport function ReactQueryProviders({ children }: { children: React.ReactNode }) {\r\n  // Create QueryClient once with production-ready configuration\r\n  const [queryClient] = React.useState(\r\n    () =>\r\n      new QueryClient({\r\n        defaultOptions: {\r\n          queries: {\r\n            staleTime: 1000 * 60 * 5, // 5 minutes - data stays fresh\r\n            gcTime: 1000 * 60 * 30, // 30 minutes - extended garbage collection for better cache hits\r\n            retry: (failureCount, error) => {\r\n              // Don't retry on 4xx errors (client errors)\r\n              if (error instanceof Error && \"status\" in error) {\r\n                const status = (error as any).status;\r\n                if (status >= 400 && status < 500) return false;\r\n              }\r\n              // Retry up to 3 times for other errors\r\n              return failureCount < 3;\r\n            },\r\n            refetchOnWindowFocus: false, // Prevent unnecessary refetches\r\n            refetchOnReconnect: true, // Refetch on network reconnect\r\n            refetchOnMount: false, // Use cached data on mount for instant navigation\r\n          },\r\n          mutations: {\r\n            retry: 1,\r\n            onError: handleMutationError,\r\n          },\r\n        },\r\n      })\r\n  );\r\n\r\n  return (\r\n    <ErrorBoundary>\r\n      <QueryClientProvider client={queryClient}>\r\n        {children}\r\n        {/* DevTools only in development */}\r\n        {process.env.NODE_ENV === \"development\" && (\r\n          <ReactQueryDevtools initialIsOpen={false} />\r\n        )}\r\n      </QueryClientProvider>\r\n    </ErrorBoundary>\r\n  );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAmES;;AAjET;AACA;AAAA;AACA;AACA;AACA;;;AANA;;;;;;AAQA,mCAAmC;AACnC,SAAS,iBAAiB,KAAc;IACtC,MAAM,UAAU,iBAAiB,QAAQ,MAAM,OAAO,GAAG;IACzD,QAAQ,KAAK,CAAC,gBAAgB;IAC9B,qKAAK,CAAC,KAAK,CAAC;AACd;AAEA,qCAAqC;AACrC,SAAS,oBAAoB,KAAU;IACrC,IAAI,UAAU;IACd,IAAI,iBAAiB,OAAO;QAC1B,UAAU,MAAM,OAAO;IACzB,OAAO,IAAI,OAAO,UAAU,YAAY,UAAU,MAAM;QACtD,UAAU,MAAM,OAAO,IAAI,MAAM,iBAAiB,IAAI,MAAM,OAAO,IAAI,KAAK,SAAS,CAAC;IACxF;IAEA,QAAQ,KAAK,CAAC,4BAA4B;QACxC;QACA;QACA,MAAM,OAAO;IACf;IACA,qKAAK,CAAC,KAAK,CAAC;AACd;AAEO,SAAS,oBAAoB,EAAE,QAAQ,EAAiC;;IAC7E,8DAA8D;IAC9D,MAAM,CAAC,YAAY,GAAG,wKAAK,CAAC,QAAQ;wCAClC,IACE,IAAI,+LAAW,CAAC;gBACd,gBAAgB;oBACd,SAAS;wBACP,WAAW,OAAO,KAAK;wBACvB,QAAQ,OAAO,KAAK;wBACpB,KAAK;4DAAE,CAAC,cAAc;gCACpB,4CAA4C;gCAC5C,IAAI,iBAAiB,SAAS,YAAY,OAAO;oCAC/C,MAAM,SAAS,AAAC,MAAc,MAAM;oCACpC,IAAI,UAAU,OAAO,SAAS,KAAK,OAAO;gCAC5C;gCACA,uCAAuC;gCACvC,OAAO,eAAe;4BACxB;;wBACA,sBAAsB;wBACtB,oBAAoB;wBACpB,gBAAgB;oBAClB;oBACA,WAAW;wBACT,OAAO;wBACP,SAAS;oBACX;gBACF;YACF;;IAGJ,qBACE,6LAAC,gJAAa;kBACZ,cAAA,6LAAC,gNAAmB;YAAC,QAAQ;;gBAC1B;gBAEA,oDAAyB,+BACxB,6LAAC,6MAAkB;oBAAC,eAAe;;;;;;;;;;;;;;;;;AAK7C;GAzCgB;KAAA"}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/components/theme-provider.tsx"],"sourcesContent":["\"use client\"\r\n\r\nimport * as React from \"react\"\r\nimport { ThemeProvider as NextThemesProvider } from \"next-themes\"\r\n\r\nexport function ThemeProvider({\r\n  children,\r\n  ...props\r\n}: React.ComponentProps<typeof NextThemesProvider>) {\r\n  return <NextThemesProvider {...props}>{children}</NextThemesProvider>\r\n}\r\n"],"names":[],"mappings":";;;;;AAGA;AAHA;;;AAKO,SAAS,cAAc,EAC5B,QAAQ,EACR,GAAG,OAC6C;IAChD,qBAAO,6LAAC,oKAAkB;QAAE,GAAG,KAAK;kBAAG;;;;;;AACzC;KALgB"}},
    {"offset": {"line": 285, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/hooks/use-toast.ts"],"sourcesContent":["'use client'\r\n\r\n// Inspired by react-hot-toast library\r\nimport * as React from 'react'\r\n\r\nimport type { ToastActionElement, ToastProps } from '@/components/ui/toast'\r\n\r\nconst TOAST_LIMIT = 1\r\nconst TOAST_REMOVE_DELAY = 1000000\r\n\r\ntype ToasterToast = ToastProps & {\r\n  id: string\r\n  title?: React.ReactNode\r\n  description?: React.ReactNode\r\n  action?: ToastActionElement\r\n}\r\n\r\nconst actionTypes = {\r\n  ADD_TOAST: 'ADD_TOAST',\r\n  UPDATE_TOAST: 'UPDATE_TOAST',\r\n  DISMISS_TOAST: 'DISMISS_TOAST',\r\n  REMOVE_TOAST: 'REMOVE_TOAST',\r\n} as const\r\n\r\nlet count = 0\r\n\r\nfunction genId() {\r\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\r\n  return count.toString()\r\n}\r\n\r\ntype ActionType = typeof actionTypes\r\n\r\ntype Action =\r\n  | {\r\n      type: ActionType['ADD_TOAST']\r\n      toast: ToasterToast\r\n    }\r\n  | {\r\n      type: ActionType['UPDATE_TOAST']\r\n      toast: Partial<ToasterToast>\r\n    }\r\n  | {\r\n      type: ActionType['DISMISS_TOAST']\r\n      toastId?: ToasterToast['id']\r\n    }\r\n  | {\r\n      type: ActionType['REMOVE_TOAST']\r\n      toastId?: ToasterToast['id']\r\n    }\r\n\r\ninterface State {\r\n  toasts: ToasterToast[]\r\n}\r\n\r\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\r\n\r\nconst addToRemoveQueue = (toastId: string) => {\r\n  if (toastTimeouts.has(toastId)) {\r\n    return\r\n  }\r\n\r\n  const timeout = setTimeout(() => {\r\n    toastTimeouts.delete(toastId)\r\n    dispatch({\r\n      type: 'REMOVE_TOAST',\r\n      toastId: toastId,\r\n    })\r\n  }, TOAST_REMOVE_DELAY)\r\n\r\n  toastTimeouts.set(toastId, timeout)\r\n}\r\n\r\nexport const reducer = (state: State, action: Action): State => {\r\n  switch (action.type) {\r\n    case 'ADD_TOAST':\r\n      return {\r\n        ...state,\r\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\r\n      }\r\n\r\n    case 'UPDATE_TOAST':\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === action.toast.id ? { ...t, ...action.toast } : t,\r\n        ),\r\n      }\r\n\r\n    case 'DISMISS_TOAST': {\r\n      const { toastId } = action\r\n\r\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\r\n      // but I'll keep it here for simplicity\r\n      if (toastId) {\r\n        addToRemoveQueue(toastId)\r\n      } else {\r\n        state.toasts.forEach((toast) => {\r\n          addToRemoveQueue(toast.id)\r\n        })\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === toastId || toastId === undefined\r\n            ? {\r\n                ...t,\r\n                open: false,\r\n              }\r\n            : t,\r\n        ),\r\n      }\r\n    }\r\n    case 'REMOVE_TOAST':\r\n      if (action.toastId === undefined) {\r\n        return {\r\n          ...state,\r\n          toasts: [],\r\n        }\r\n      }\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\r\n      }\r\n  }\r\n}\r\n\r\nconst listeners: Array<(state: State) => void> = []\r\n\r\nlet memoryState: State = { toasts: [] }\r\n\r\nfunction dispatch(action: Action) {\r\n  memoryState = reducer(memoryState, action)\r\n  listeners.forEach((listener) => {\r\n    listener(memoryState)\r\n  })\r\n}\r\n\r\ntype Toast = Omit<ToasterToast, 'id'>\r\n\r\nfunction toast({ ...props }: Toast) {\r\n  const id = genId()\r\n\r\n  const update = (props: ToasterToast) =>\r\n    dispatch({\r\n      type: 'UPDATE_TOAST',\r\n      toast: { ...props, id },\r\n    })\r\n  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id })\r\n\r\n  dispatch({\r\n    type: 'ADD_TOAST',\r\n    toast: {\r\n      ...props,\r\n      id,\r\n      open: true,\r\n      onOpenChange: (open) => {\r\n        if (!open) dismiss()\r\n      },\r\n    },\r\n  })\r\n\r\n  return {\r\n    id: id,\r\n    dismiss,\r\n    update,\r\n  }\r\n}\r\n\r\nfunction useToast() {\r\n  const [state, setState] = React.useState<State>(memoryState)\r\n\r\n  React.useEffect(() => {\r\n    listeners.push(setState)\r\n    return () => {\r\n      const index = listeners.indexOf(setState)\r\n      if (index > -1) {\r\n        listeners.splice(index, 1)\r\n      }\r\n    }\r\n  }, [state])\r\n\r\n  return {\r\n    ...state,\r\n    toast,\r\n    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),\r\n  }\r\n}\r\n\r\nexport { useToast, toast }\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from 'clsx'\r\nimport { twMerge } from 'tailwind-merge'\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs))\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,yKAAO,EAAC,IAAA,gJAAI,EAAC;AACtB"}},
    {"offset": {"line": 470, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/components/ui/toast.tsx"],"sourcesContent":["'use client'\r\n\r\nimport * as React from 'react'\r\nimport * as ToastPrimitives from '@radix-ui/react-toast'\r\nimport { cva, type VariantProps } from 'class-variance-authority'\r\nimport { X } from 'lucide-react'\r\n\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst ToastProvider = ToastPrimitives.Provider\r\n\r\nconst ToastViewport = React.forwardRef<\r\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\r\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\r\n>(({ className, ...props }, ref) => (\r\n  <ToastPrimitives.Viewport\r\n    ref={ref}\r\n    className={cn(\r\n      'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\r\n\r\nconst toastVariants = cva(\r\n  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: 'border bg-background text-foreground',\r\n        destructive:\r\n          'destructive group border-destructive bg-destructive text-destructive-foreground',\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: 'default',\r\n    },\r\n  },\r\n)\r\n\r\nconst Toast = React.forwardRef<\r\n  React.ElementRef<typeof ToastPrimitives.Root>,\r\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\r\n    VariantProps<typeof toastVariants>\r\n>(({ className, variant, ...props }, ref) => {\r\n  return (\r\n    <ToastPrimitives.Root\r\n      ref={ref}\r\n      className={cn(toastVariants({ variant }), className)}\r\n      {...props}\r\n    />\r\n  )\r\n})\r\nToast.displayName = ToastPrimitives.Root.displayName\r\n\r\nconst ToastAction = React.forwardRef<\r\n  React.ElementRef<typeof ToastPrimitives.Action>,\r\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\r\n>(({ className, ...props }, ref) => (\r\n  <ToastPrimitives.Action\r\n    ref={ref}\r\n    className={cn(\r\n      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive',\r\n      className,\r\n    )}\r\n    {...props}\r\n  />\r\n))\r\nToastAction.displayName = ToastPrimitives.Action.displayName\r\n\r\nconst ToastClose = React.forwardRef<\r\n  React.ElementRef<typeof ToastPrimitives.Close>,\r\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\r\n>(({ className, ...props }, ref) => (\r\n  <ToastPrimitives.Close\r\n    ref={ref}\r\n    className={cn(\r\n      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600',\r\n      className,\r\n    )}\r\n    toast-close=\"\"\r\n    {...props}\r\n  >\r\n    <X className=\"h-4 w-4\" />\r\n  </ToastPrimitives.Close>\r\n))\r\nToastClose.displayName = ToastPrimitives.Close.displayName\r\n\r\nconst ToastTitle = React.forwardRef<\r\n  React.ElementRef<typeof ToastPrimitives.Title>,\r\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\r\n>(({ className, ...props }, ref) => (\r\n  <ToastPrimitives.Title\r\n    ref={ref}\r\n    className={cn('text-sm font-semibold', className)}\r\n    {...props}\r\n  />\r\n))\r\nToastTitle.displayName = ToastPrimitives.Title.displayName\r\n\r\nconst ToastDescription = React.forwardRef<\r\n  React.ElementRef<typeof ToastPrimitives.Description>,\r\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\r\n>(({ className, ...props }, ref) => (\r\n  <ToastPrimitives.Description\r\n    ref={ref}\r\n    className={cn('text-sm opacity-90', className)}\r\n    {...props}\r\n  />\r\n))\r\nToastDescription.displayName = ToastPrimitives.Description.displayName\r\n\r\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\r\n\r\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\r\n\r\nexport {\r\n  type ToastProps,\r\n  type ToastActionElement,\r\n  ToastProvider,\r\n  ToastViewport,\r\n  Toast,\r\n  ToastTitle,\r\n  ToastDescription,\r\n  ToastClose,\r\n  ToastAction,\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AAPA;;;;;;;AASA,MAAM,gBAAgB,gLAAwB;AAE9C,MAAM,8BAAgB,2KAAgB,MAGpC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,gLAAwB;QACvB,KAAK;QACL,WAAW,IAAA,qHAAE,EACX,qIACA;QAED,GAAG,KAAK;;;;;;;AAGb,cAAc,WAAW,GAAG,gLAAwB,CAAC,WAAW;AAEhE,MAAM,gBAAgB,IAAA,0KAAG,EACvB,6lBACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAGF,MAAM,sBAAQ,2KAAgB,OAI5B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAO,EAAE;IACnC,qBACE,6LAAC,4KAAoB;QACnB,KAAK;QACL,WAAW,IAAA,qHAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QACzC,GAAG,KAAK;;;;;;AAGf;;AACA,MAAM,WAAW,GAAG,4KAAoB,CAAC,WAAW;AAEpD,MAAM,4BAAc,2KAAgB,OAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,8KAAsB;QACrB,KAAK;QACL,WAAW,IAAA,qHAAE,EACX,sgBACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,8KAAsB,CAAC,WAAW;AAE5D,MAAM,2BAAa,2KAAgB,OAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,6KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,qHAAE,EACX,yVACA;QAEF,eAAY;QACX,GAAG,KAAK;kBAET,cAAA,6LAAC,oMAAC;YAAC,WAAU;;;;;;;;;;;;AAGjB,WAAW,WAAW,GAAG,6KAAqB,CAAC,WAAW;AAE1D,MAAM,2BAAa,2KAAgB,OAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,6KAAqB;QACpB,KAAK;QACL,WAAW,IAAA,qHAAE,EAAC,yBAAyB;QACtC,GAAG,KAAK;;;;;;;AAGb,WAAW,WAAW,GAAG,6KAAqB,CAAC,WAAW;AAE1D,MAAM,iCAAmB,2KAAgB,QAGvC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,mLAA2B;QAC1B,KAAK;QACL,WAAW,IAAA,qHAAE,EAAC,sBAAsB;QACnC,GAAG,KAAK;;;;;;;AAGb,iBAAiB,WAAW,GAAG,mLAA2B,CAAC,WAAW"}},
    {"offset": {"line": 610, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/components/ui/toaster.tsx"],"sourcesContent":["'use client'\r\n\r\nimport { useToast } from '@/hooks/use-toast'\r\nimport {\r\n  Toast,\r\n  ToastClose,\r\n  ToastDescription,\r\n  ToastProvider,\r\n  ToastTitle,\r\n  ToastViewport,\r\n} from '@/components/ui/toast'\r\n\r\nexport function Toaster() {\r\n  const { toasts } = useToast()\r\n\r\n  return (\r\n    <ToastProvider>\r\n      {toasts.map(function ({ id, title, description, action, ...props }) {\r\n        return (\r\n          <Toast key={id} {...props}>\r\n            <div className=\"grid gap-1\">\r\n              {title && <ToastTitle>{title}</ToastTitle>}\r\n              {description && (\r\n                <ToastDescription>{description}</ToastDescription>\r\n              )}\r\n            </div>\r\n            {action}\r\n            <ToastClose />\r\n          </Toast>\r\n        )\r\n      })}\r\n      <ToastViewport />\r\n    </ToastProvider>\r\n  )\r\n}\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;AAHA;;;AAYO,SAAS;;IACd,MAAM,EAAE,MAAM,EAAE,GAAG,IAAA,oIAAQ;IAE3B,qBACE,6LAAC,8IAAa;;YACX,OAAO,GAAG,CAAC,SAAU,EAAE,EAAE,EAAE,KAAK,EAAE,WAAW,EAAE,MAAM,EAAE,GAAG,OAAO;gBAChE,qBACE,6LAAC,sIAAK;oBAAW,GAAG,KAAK;;sCACvB,6LAAC;4BAAI,WAAU;;gCACZ,uBAAS,6LAAC,2IAAU;8CAAE;;;;;;gCACtB,6BACC,6LAAC,iJAAgB;8CAAE;;;;;;;;;;;;wBAGtB;sCACD,6LAAC,2IAAU;;;;;;mBARD;;;;;YAWhB;0BACA,6LAAC,8IAAa;;;;;;;;;;;AAGpB;GAtBgB;;QACK,oIAAQ;;;KADb"}},
    {"offset": {"line": 694, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/app/actions/rewardActions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { createClient } from \"@/lib/supabase/server\";\r\nimport { revalidatePath } from \"next/cache\";\r\n\r\ntype ActionType = 'login' | 'video_watch' | 'lesson_completion' | 'quiz_completion' | 'module_completion' | 'referral' | 'bonus' | 'mission_complete';\r\n\r\nconst REWARD_RULES = {\r\n    login: { coins: 5, limit: 1 },\r\n    video_watch: { coins: 10, limit: 10 },\r\n    lesson_completion: { coins: 10, limit: 20 }, // Generic lesson completion\r\n    quiz_completion: { coins: 15, limit: 10 },\r\n    quiz_bonus: { coins: 10, limit: 10 },\r\n    module_completion: { coins: 50, limit: 5 },\r\n    referral: { coins: 100, limit: 10 },\r\n    streak_3: { coins: 10, limit: 1 },\r\n    streak_7: { coins: 30, limit: 1 },\r\n    streak_30: { coins: 100, limit: 1 },\r\n    mission_complete: { coins: 20, limit: 3 }\r\n};\r\n\r\nconst DAILY_COIN_CAP = 100;\r\n\r\nexport async function getRewardStatus(userId: string) {\r\n    const supabase = await createClient();\r\n    let { data } = await supabase\r\n        .from(\"user_rewards\")\r\n        .select(\"*\")\r\n        .eq(\"user_id\", userId)\r\n        .single();\r\n\r\n    if (!data) {\r\n        // Initialize if not exists\r\n        const { data: newData, error } = await supabase\r\n            .from(\"user_rewards\")\r\n            .insert({ user_id: userId })\r\n            .select()\r\n            .single();\r\n\r\n        if (error) {\r\n            if (error.code === '23505') {\r\n                const { data: retryData } = await supabase\r\n                    .from(\"user_rewards\")\r\n                    .select(\"*\")\r\n                    .eq(\"user_id\", userId)\r\n                    .single();\r\n                data = retryData;\r\n            } else {\r\n                console.error(\"Error creating user_rewards in getRewardStatus:\", error);\r\n                return null;\r\n            }\r\n        } else {\r\n            data = newData;\r\n        }\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\nexport async function checkStreak(userId: string) {\r\n    const supabase = await createClient();\r\n\r\n    // Just fetch the current status to display to the user\r\n    // The actual update happens when 'login' reward is awarded below\r\n    const { data: rewardStatus } = await supabase\r\n        .from(\"user_rewards\")\r\n        .select(\"current_streak, longest_streak, last_activity_date\")\r\n        .eq(\"user_id\", userId)\r\n        .single();\r\n\r\n    if (!rewardStatus) return { streak: 0, message: null };\r\n\r\n    // We can infer if they are on a streak or if it's broken based on the date,\r\n    // but primarily we just want to show the current value.\r\n    // The DB trigger updates this immediately upon the 'login' transaction insertion.\r\n\r\n    return {\r\n        streak: rewardStatus.current_streak,\r\n        message: null\r\n    };\r\n}\r\n\r\nexport async function awardCoins(\r\n    userId: string,\r\n    action: ActionType,\r\n    entityId?: string,\r\n    description?: string\r\n) {\r\n    const supabase = await createClient();\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    // 1. Check strict duplicate rules (Client-Side Protection)\r\n    // We don't want to spam the DB trigger with 'login' events every refresh\r\n    if (action === 'login') {\r\n        entityId = today; // Force entityId to be date for login\r\n    }\r\n\r\n    if (entityId) {\r\n        const { data: existing } = await supabase\r\n            .from(\"reward_transactions\")\r\n            .select(\"id\")\r\n            .eq(\"user_id\", userId)\r\n            .eq(\"action_type\", action)\r\n            .eq(\"entity_id\", entityId)\r\n            .gte(\"created_at\", `${today}T00:00:00`)\r\n            .single();\r\n\r\n        if (existing) {\r\n            return { success: false, message: \"Already rewarded for this today!\" };\r\n        }\r\n    }\r\n\r\n    // 2. Define Amount (We still define it here to pass to DB, or DB could handle default)\r\n    let coins = 0;\r\n    switch (action) {\r\n        case 'login': coins = REWARD_RULES.login.coins; break;\r\n        case 'video_watch': coins = REWARD_RULES.video_watch.coins; break;\r\n        case 'lesson_completion': coins = REWARD_RULES.lesson_completion.coins; break;\r\n        case 'quiz_completion': coins = REWARD_RULES.quiz_completion.coins; break;\r\n        case 'module_completion': coins = REWARD_RULES.module_completion.coins; break;\r\n        case 'referral': coins = REWARD_RULES.referral.coins; break;\r\n        case 'mission_complete': coins = REWARD_RULES.mission_complete.coins; break;\r\n        case 'bonus': coins = 10; break;\r\n        default: coins = 0;\r\n    }\r\n\r\n    // 3. Insert Transaction (The DB Trigger takes it from here!)\r\n    // It will: Update Coins, XP, Level, and Streak (if login)\r\n    const { error } = await supabase.from(\"reward_transactions\").insert({\r\n        user_id: userId,\r\n        amount: coins,\r\n        action_type: action,\r\n        entity_id: entityId,\r\n        description: description || `Reward for ${action}`\r\n    });\r\n\r\n    if (error) {\r\n        console.error(\"Reward Insert Error:\", error);\r\n        return { success: false, message: \"Failed to process reward.\" };\r\n    }\r\n\r\n    // 4. Post-Process (Optional Notifications or Revalidation)\r\n    revalidatePath(\"/student\");\r\n\r\n    if (action === 'login') {\r\n        // Special message for login\r\n        return { success: true, coins, message: \"Daily Reward Claimed!\" };\r\n    }\r\n\r\n    return { success: true, coins, message: `⭐ +${coins} coins!` };\r\n}\r\n\r\nexport async function getLeaderboard(type: 'weekly' | 'all_time' = 'all_time', limit: number = 10) {\r\n    const supabase = await createClient();\r\n\r\n    const sortColumn = type === 'weekly' ? 'weekly_xp' : 'total_coins'; // or xp\r\n\r\n    const { data } = await supabase\r\n        .from(\"user_rewards\")\r\n        .select(`\r\n            total_coins,\r\n            xp,\r\n            weekly_xp,\r\n            level,\r\n            current_streak,\r\n            user_id,\r\n            profiles:user_id (\r\n                full_name,\r\n                avatar_url\r\n            )\r\n        `)\r\n        .order(sortColumn, { ascending: false })\r\n        .limit(limit);\r\n\r\n    return data?.map((entry: any) => ({\r\n        ...entry,\r\n        profiles: Array.isArray(entry.profiles) ? entry.profiles[0] : entry.profiles\r\n    })) || [];\r\n}\r\n\r\nexport async function checkModuleCompletion(userId: string, moduleId: string) {\r\n    const supabase = await createClient();\r\n    const { data: lessons } = await supabase.from(\"lessons\").select(\"id\").eq(\"module_id\", moduleId);\r\n    if (!lessons || lessons.length === 0) return;\r\n\r\n    const { data: completed } = await supabase\r\n        .from(\"lesson_progress\")\r\n        .select(\"lesson_id\")\r\n        .eq(\"user_id\", userId)\r\n        .eq(\"completed\", true)\r\n        .in(\"lesson_id\", lessons.map(l => l.id));\r\n\r\n    const completedCount = completed?.length || 0;\r\n    if (completedCount === lessons.length) {\r\n        return await awardCoins(userId, 'module_completion', moduleId, 'Completed a module!');\r\n    }\r\n    return null;\r\n}\r\n\r\nexport async function checkFirstLessonReward(userId: string) {\r\n    const supabase = await createClient();\r\n    const { count } = await supabase\r\n        .from(\"lesson_progress\")\r\n        .select(\"*\", { count: 'exact', head: true })\r\n        .eq(\"user_id\", userId)\r\n        .eq(\"completed\", true);\r\n\r\n    if (count !== 1) return;\r\n\r\n    const { data: profile } = await supabase\r\n        .from(\"profiles\")\r\n        .select(\"referred_by\")\r\n        .eq(\"id\", userId)\r\n        .single();\r\n\r\n    if (!profile?.referred_by) return;\r\n\r\n    const referrerId = profile.referred_by;\r\n    const { data: existing } = await supabase\r\n        .from(\"reward_transactions\")\r\n        .select(\"*\")\r\n        .eq(\"user_id\", referrerId)\r\n        .eq(\"action_type\", 'referral')\r\n        .eq(\"entity_id\", userId)\r\n        .single();\r\n\r\n    if (existing) return;\r\n\r\n    // Award referrer\r\n    await awardCoins(referrerId, 'referral', userId, `Referral bonus for user ${userId}`);\r\n\r\n    // Check Badge for Referrer\r\n    await checkBadgeUnlock(referrerId, 'social_butterfly');\r\n}\r\n\r\n// --- NEW GAMIFICATION FUNCTIONS ---\r\n\r\nexport async function getDailyMissions(userId: string) {\r\n    const supabase = await createClient();\r\n\r\n    // Use RPC function to get or create missions\r\n    const { data, error } = await supabase.rpc('get_or_create_daily_missions', {\r\n        p_user_id: userId\r\n    });\r\n\r\n    if (error) {\r\n        console.error(\"Error fetching daily missions:\", error);\r\n        return [];\r\n    }\r\n\r\n    return data || [];\r\n}\r\n\r\n\r\nexport async function updateMissionProgress(userId: string, type: 'login' | 'quiz' | 'video') {\r\n    const supabase = await createClient();\r\n\r\n    // Use RPC function to update mission progress\r\n    const { data, error } = await supabase.rpc('update_mission_progress', {\r\n        p_user_id: userId,\r\n        p_mission_type: type\r\n    });\r\n\r\n    if (error) {\r\n        console.error(\"Error updating mission progress:\", error);\r\n        return;\r\n    }\r\n\r\n    // Check if any mission was completed\r\n    const missions = data || [];\r\n    const completedMission = missions.find((m: any) =>\r\n        m.id === type && m.completed && m.progress === m.goal\r\n    );\r\n\r\n    if (completedMission) {\r\n        // Award mission bonus\r\n        const today = new Date().toISOString().split('T')[0];\r\n        await awardCoins(userId, 'mission_complete', `${today}-${type}`, `Mission Complete: ${completedMission.title}`);\r\n    }\r\n\r\n    revalidatePath(\"/student\");\r\n}\r\n\r\n\r\nexport async function checkBadgeUnlock(userId: string, badgeId: string) {\r\n    const supabase = await createClient();\r\n\r\n    // Check if already has badge\r\n    const { data: existing } = await supabase\r\n        .from(\"user_badges\")\r\n        .select(\"*\")\r\n        .eq(\"user_id\", userId)\r\n        .eq(\"badge_id\", badgeId)\r\n        .single();\r\n\r\n    if (existing) return;\r\n\r\n    // Logic to verify if they actually earned it could go here, \r\n    // but usually we call this function when we KNOW they met the condition.\r\n\r\n    await supabase.from(\"user_badges\").insert({\r\n        user_id: userId,\r\n        badge_id: badgeId\r\n    });\r\n\r\n    // Could return a notification object\r\n}\r\n\r\nexport async function getUserBadges(userId: string) {\r\n    const supabase = await createClient();\r\n    const { data } = await supabase\r\n        .from(\"user_badges\")\r\n        .select(\"badge_id, earned_at\")\r\n        .eq(\"user_id\", userId);\r\n    return data || [];\r\n}\r\n\r\nexport async function getStreakHistory(userId: string) {\r\n    const supabase = await createClient();\r\n\r\n    // Fetch dates from reward_transactions\r\n    const { data } = await supabase\r\n        .from(\"reward_transactions\")\r\n        .select(\"created_at\")\r\n        .eq(\"user_id\", userId)\r\n        .order(\"created_at\", { ascending: false });\r\n\r\n    if (!data) return [];\r\n\r\n    // Extract unique dates (YYYY-MM-DD)\r\n    const uniqueDates = new Set(\r\n        data.map(item => item.created_at.split('T')[0])\r\n    );\r\n\r\n    return Array.from(uniqueDates);\r\n}\r\n"],"names":[],"mappings":";;;;;;;IAkFsB,aAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 709, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/app/actions/rewardActions.ts"],"sourcesContent":["\"use server\";\r\n\r\nimport { createClient } from \"@/lib/supabase/server\";\r\nimport { revalidatePath } from \"next/cache\";\r\n\r\ntype ActionType = 'login' | 'video_watch' | 'lesson_completion' | 'quiz_completion' | 'module_completion' | 'referral' | 'bonus' | 'mission_complete';\r\n\r\nconst REWARD_RULES = {\r\n    login: { coins: 5, limit: 1 },\r\n    video_watch: { coins: 10, limit: 10 },\r\n    lesson_completion: { coins: 10, limit: 20 }, // Generic lesson completion\r\n    quiz_completion: { coins: 15, limit: 10 },\r\n    quiz_bonus: { coins: 10, limit: 10 },\r\n    module_completion: { coins: 50, limit: 5 },\r\n    referral: { coins: 100, limit: 10 },\r\n    streak_3: { coins: 10, limit: 1 },\r\n    streak_7: { coins: 30, limit: 1 },\r\n    streak_30: { coins: 100, limit: 1 },\r\n    mission_complete: { coins: 20, limit: 3 }\r\n};\r\n\r\nconst DAILY_COIN_CAP = 100;\r\n\r\nexport async function getRewardStatus(userId: string) {\r\n    const supabase = await createClient();\r\n    let { data } = await supabase\r\n        .from(\"user_rewards\")\r\n        .select(\"*\")\r\n        .eq(\"user_id\", userId)\r\n        .single();\r\n\r\n    if (!data) {\r\n        // Initialize if not exists\r\n        const { data: newData, error } = await supabase\r\n            .from(\"user_rewards\")\r\n            .insert({ user_id: userId })\r\n            .select()\r\n            .single();\r\n\r\n        if (error) {\r\n            if (error.code === '23505') {\r\n                const { data: retryData } = await supabase\r\n                    .from(\"user_rewards\")\r\n                    .select(\"*\")\r\n                    .eq(\"user_id\", userId)\r\n                    .single();\r\n                data = retryData;\r\n            } else {\r\n                console.error(\"Error creating user_rewards in getRewardStatus:\", error);\r\n                return null;\r\n            }\r\n        } else {\r\n            data = newData;\r\n        }\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\nexport async function checkStreak(userId: string) {\r\n    const supabase = await createClient();\r\n\r\n    // Just fetch the current status to display to the user\r\n    // The actual update happens when 'login' reward is awarded below\r\n    const { data: rewardStatus } = await supabase\r\n        .from(\"user_rewards\")\r\n        .select(\"current_streak, longest_streak, last_activity_date\")\r\n        .eq(\"user_id\", userId)\r\n        .single();\r\n\r\n    if (!rewardStatus) return { streak: 0, message: null };\r\n\r\n    // We can infer if they are on a streak or if it's broken based on the date,\r\n    // but primarily we just want to show the current value.\r\n    // The DB trigger updates this immediately upon the 'login' transaction insertion.\r\n\r\n    return {\r\n        streak: rewardStatus.current_streak,\r\n        message: null\r\n    };\r\n}\r\n\r\nexport async function awardCoins(\r\n    userId: string,\r\n    action: ActionType,\r\n    entityId?: string,\r\n    description?: string\r\n) {\r\n    const supabase = await createClient();\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    // 1. Check strict duplicate rules (Client-Side Protection)\r\n    // We don't want to spam the DB trigger with 'login' events every refresh\r\n    if (action === 'login') {\r\n        entityId = today; // Force entityId to be date for login\r\n    }\r\n\r\n    if (entityId) {\r\n        const { data: existing } = await supabase\r\n            .from(\"reward_transactions\")\r\n            .select(\"id\")\r\n            .eq(\"user_id\", userId)\r\n            .eq(\"action_type\", action)\r\n            .eq(\"entity_id\", entityId)\r\n            .gte(\"created_at\", `${today}T00:00:00`)\r\n            .single();\r\n\r\n        if (existing) {\r\n            return { success: false, message: \"Already rewarded for this today!\" };\r\n        }\r\n    }\r\n\r\n    // 2. Define Amount (We still define it here to pass to DB, or DB could handle default)\r\n    let coins = 0;\r\n    switch (action) {\r\n        case 'login': coins = REWARD_RULES.login.coins; break;\r\n        case 'video_watch': coins = REWARD_RULES.video_watch.coins; break;\r\n        case 'lesson_completion': coins = REWARD_RULES.lesson_completion.coins; break;\r\n        case 'quiz_completion': coins = REWARD_RULES.quiz_completion.coins; break;\r\n        case 'module_completion': coins = REWARD_RULES.module_completion.coins; break;\r\n        case 'referral': coins = REWARD_RULES.referral.coins; break;\r\n        case 'mission_complete': coins = REWARD_RULES.mission_complete.coins; break;\r\n        case 'bonus': coins = 10; break;\r\n        default: coins = 0;\r\n    }\r\n\r\n    // 3. Insert Transaction (The DB Trigger takes it from here!)\r\n    // It will: Update Coins, XP, Level, and Streak (if login)\r\n    const { error } = await supabase.from(\"reward_transactions\").insert({\r\n        user_id: userId,\r\n        amount: coins,\r\n        action_type: action,\r\n        entity_id: entityId,\r\n        description: description || `Reward for ${action}`\r\n    });\r\n\r\n    if (error) {\r\n        console.error(\"Reward Insert Error:\", error);\r\n        return { success: false, message: \"Failed to process reward.\" };\r\n    }\r\n\r\n    // 4. Post-Process (Optional Notifications or Revalidation)\r\n    revalidatePath(\"/student\");\r\n\r\n    if (action === 'login') {\r\n        // Special message for login\r\n        return { success: true, coins, message: \"Daily Reward Claimed!\" };\r\n    }\r\n\r\n    return { success: true, coins, message: `⭐ +${coins} coins!` };\r\n}\r\n\r\nexport async function getLeaderboard(type: 'weekly' | 'all_time' = 'all_time', limit: number = 10) {\r\n    const supabase = await createClient();\r\n\r\n    const sortColumn = type === 'weekly' ? 'weekly_xp' : 'total_coins'; // or xp\r\n\r\n    const { data } = await supabase\r\n        .from(\"user_rewards\")\r\n        .select(`\r\n            total_coins,\r\n            xp,\r\n            weekly_xp,\r\n            level,\r\n            current_streak,\r\n            user_id,\r\n            profiles:user_id (\r\n                full_name,\r\n                avatar_url\r\n            )\r\n        `)\r\n        .order(sortColumn, { ascending: false })\r\n        .limit(limit);\r\n\r\n    return data?.map((entry: any) => ({\r\n        ...entry,\r\n        profiles: Array.isArray(entry.profiles) ? entry.profiles[0] : entry.profiles\r\n    })) || [];\r\n}\r\n\r\nexport async function checkModuleCompletion(userId: string, moduleId: string) {\r\n    const supabase = await createClient();\r\n    const { data: lessons } = await supabase.from(\"lessons\").select(\"id\").eq(\"module_id\", moduleId);\r\n    if (!lessons || lessons.length === 0) return;\r\n\r\n    const { data: completed } = await supabase\r\n        .from(\"lesson_progress\")\r\n        .select(\"lesson_id\")\r\n        .eq(\"user_id\", userId)\r\n        .eq(\"completed\", true)\r\n        .in(\"lesson_id\", lessons.map(l => l.id));\r\n\r\n    const completedCount = completed?.length || 0;\r\n    if (completedCount === lessons.length) {\r\n        return await awardCoins(userId, 'module_completion', moduleId, 'Completed a module!');\r\n    }\r\n    return null;\r\n}\r\n\r\nexport async function checkFirstLessonReward(userId: string) {\r\n    const supabase = await createClient();\r\n    const { count } = await supabase\r\n        .from(\"lesson_progress\")\r\n        .select(\"*\", { count: 'exact', head: true })\r\n        .eq(\"user_id\", userId)\r\n        .eq(\"completed\", true);\r\n\r\n    if (count !== 1) return;\r\n\r\n    const { data: profile } = await supabase\r\n        .from(\"profiles\")\r\n        .select(\"referred_by\")\r\n        .eq(\"id\", userId)\r\n        .single();\r\n\r\n    if (!profile?.referred_by) return;\r\n\r\n    const referrerId = profile.referred_by;\r\n    const { data: existing } = await supabase\r\n        .from(\"reward_transactions\")\r\n        .select(\"*\")\r\n        .eq(\"user_id\", referrerId)\r\n        .eq(\"action_type\", 'referral')\r\n        .eq(\"entity_id\", userId)\r\n        .single();\r\n\r\n    if (existing) return;\r\n\r\n    // Award referrer\r\n    await awardCoins(referrerId, 'referral', userId, `Referral bonus for user ${userId}`);\r\n\r\n    // Check Badge for Referrer\r\n    await checkBadgeUnlock(referrerId, 'social_butterfly');\r\n}\r\n\r\n// --- NEW GAMIFICATION FUNCTIONS ---\r\n\r\nexport async function getDailyMissions(userId: string) {\r\n    const supabase = await createClient();\r\n\r\n    // Use RPC function to get or create missions\r\n    const { data, error } = await supabase.rpc('get_or_create_daily_missions', {\r\n        p_user_id: userId\r\n    });\r\n\r\n    if (error) {\r\n        console.error(\"Error fetching daily missions:\", error);\r\n        return [];\r\n    }\r\n\r\n    return data || [];\r\n}\r\n\r\n\r\nexport async function updateMissionProgress(userId: string, type: 'login' | 'quiz' | 'video') {\r\n    const supabase = await createClient();\r\n\r\n    // Use RPC function to update mission progress\r\n    const { data, error } = await supabase.rpc('update_mission_progress', {\r\n        p_user_id: userId,\r\n        p_mission_type: type\r\n    });\r\n\r\n    if (error) {\r\n        console.error(\"Error updating mission progress:\", error);\r\n        return;\r\n    }\r\n\r\n    // Check if any mission was completed\r\n    const missions = data || [];\r\n    const completedMission = missions.find((m: any) =>\r\n        m.id === type && m.completed && m.progress === m.goal\r\n    );\r\n\r\n    if (completedMission) {\r\n        // Award mission bonus\r\n        const today = new Date().toISOString().split('T')[0];\r\n        await awardCoins(userId, 'mission_complete', `${today}-${type}`, `Mission Complete: ${completedMission.title}`);\r\n    }\r\n\r\n    revalidatePath(\"/student\");\r\n}\r\n\r\n\r\nexport async function checkBadgeUnlock(userId: string, badgeId: string) {\r\n    const supabase = await createClient();\r\n\r\n    // Check if already has badge\r\n    const { data: existing } = await supabase\r\n        .from(\"user_badges\")\r\n        .select(\"*\")\r\n        .eq(\"user_id\", userId)\r\n        .eq(\"badge_id\", badgeId)\r\n        .single();\r\n\r\n    if (existing) return;\r\n\r\n    // Logic to verify if they actually earned it could go here, \r\n    // but usually we call this function when we KNOW they met the condition.\r\n\r\n    await supabase.from(\"user_badges\").insert({\r\n        user_id: userId,\r\n        badge_id: badgeId\r\n    });\r\n\r\n    // Could return a notification object\r\n}\r\n\r\nexport async function getUserBadges(userId: string) {\r\n    const supabase = await createClient();\r\n    const { data } = await supabase\r\n        .from(\"user_badges\")\r\n        .select(\"badge_id, earned_at\")\r\n        .eq(\"user_id\", userId);\r\n    return data || [];\r\n}\r\n\r\nexport async function getStreakHistory(userId: string) {\r\n    const supabase = await createClient();\r\n\r\n    // Fetch dates from reward_transactions\r\n    const { data } = await supabase\r\n        .from(\"reward_transactions\")\r\n        .select(\"created_at\")\r\n        .eq(\"user_id\", userId)\r\n        .order(\"created_at\", { ascending: false });\r\n\r\n    if (!data) return [];\r\n\r\n    // Extract unique dates (YYYY-MM-DD)\r\n    const uniqueDates = new Set(\r\n        data.map(item => item.created_at.split('T')[0])\r\n    );\r\n\r\n    return Array.from(uniqueDates);\r\n}\r\n"],"names":[],"mappings":";;;;;;;IA8PsB,wBAAA,WAAA,GAAA,IAAA,kPAAA,EAAA,8CAAA,uOAAA,EAAA,KAAA,GAAA,6OAAA,EAAA"}},
    {"offset": {"line": 724, "column": 0}, "map": {"version":3,"sources":["file:///E:/PROJECT%202025%20-%20October/math4code-website/components/RewardInitializer.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport { useEffect } from \"react\";\r\nimport { checkStreak, awardCoins, updateMissionProgress } from \"@/app/actions/rewardActions\";\r\nimport { toast } from \"sonner\";\r\nimport { usePathname } from \"next/navigation\";\r\n\r\nexport function RewardInitializer({ userId }: { userId: string }) {\r\n    const pathname = usePathname();\r\n\r\n    useEffect(() => {\r\n        if (!userId) return;\r\n\r\n        const initRewards = async () => {\r\n            // New Flow: Trigger 'login' action. \r\n            // The DB Trigger handles Streak Updates + Coin Awards automatically.\r\n            const loginRes = await awardCoins(userId, 'login');\r\n\r\n            if (loginRes.success && loginRes.message) {\r\n                toast.success(loginRes.message, {\r\n                    icon: \"🔥\",\r\n                    duration: 3000\r\n                });\r\n                // Dispatch event to refresh UI counters\r\n                window.dispatchEvent(new Event(\"rewards-updated\"));\r\n            }\r\n\r\n            // Update login mission progress\r\n            await updateMissionProgress(userId, 'login');\r\n        };\r\n\r\n        // Run once on mount (session start)\r\n        initRewards();\r\n    }, [userId]); // Dependency on userId ensures it runs when user is available\r\n\r\n    return null; // This component renders nothing\r\n}\r\n"],"names":[],"mappings":";;;;AAEA;AACA;AAAA;AACA;AACA;;AALA;;;;;AAOO,SAAS,kBAAkB,EAAE,MAAM,EAAsB;;IAC5D,MAAM,WAAW,IAAA,oJAAW;IAE5B,IAAA,0KAAS;uCAAC;YACN,IAAI,CAAC,QAAQ;YAEb,MAAM;2DAAc;oBAChB,qCAAqC;oBACrC,qEAAqE;oBACrE,MAAM,WAAW,MAAM,IAAA,uKAAU,EAAC,QAAQ;oBAE1C,IAAI,SAAS,OAAO,IAAI,SAAS,OAAO,EAAE;wBACtC,oJAAK,CAAC,OAAO,CAAC,SAAS,OAAO,EAAE;4BAC5B,MAAM;4BACN,UAAU;wBACd;wBACA,wCAAwC;wBACxC,OAAO,aAAa,CAAC,IAAI,MAAM;oBACnC;oBAEA,gCAAgC;oBAChC,MAAM,IAAA,kLAAqB,EAAC,QAAQ;gBACxC;;YAEA,oCAAoC;YACpC;QACJ;sCAAG;QAAC;KAAO,GAAG,8DAA8D;IAE5E,OAAO,MAAM,iCAAiC;AAClD;GA7BgB;;QACK,oJAAW;;;KADhB"}}]
}